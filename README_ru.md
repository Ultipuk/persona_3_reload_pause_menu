# Persona 3 Reload. Pause Menu UI

[English version](README.md)

Текст ниже это не гайд, а заметки в разном порятке. В проекте много ленивых вещей и хардкода. Моей целью было не сделать референсный проект, а научиться работать с UI в Godot. А вдохновил меня на это интерфейс паузы из _Persona 3 Reload_. Собственно, главное меню паузы я и сделал.

### Демонстрация

https://github.com/user-attachments/assets/808a1fa9-906e-4ff7-bc77-a09012825039

[Смотреть на YouTube](https://www.youtube.com/watch?v=PL8FhfQNRS4)

### Референсы

- За звуки спасибо [graaveaty](https://www.youtube.com/@graaveaty).
- 3D модель Макото взял [отсюда](https://sketchfab.com/3d-models/makoto-yukiminato-arisato-persona-3-85308017127c43e991e646fa5c32b71d).
- Картинки клавиш сделал вездесущий [Kenney](https://www.kenney.nl/).
- Шрифт Monsterrat.
- За референс использовал [вот этот видос](https://www.youtube.com/watch?v=4d6x1CIgLSc). Спасибо John Persona.
- Очень помог видос [Acerola](https://www.youtube.com/watch?v=dVWkPADNdJ4).
- Шейдер размытия по Гауссу взял [отсюда](https://godotshaders.com/shader/gaussian-blur-2/).


## Вьюпорты

Вьюпортов много. Они помещаются в соответствующие контейнеры, и на них часто накладываются шейдеры. Это решение продиктовано необходимостью объеденять ноды в группы для рендера.

Если вьюпорты не видны, то они не рендерятся (включена соответствующая опция). Поэтому я прячу ненужные мне вьюпорты.

Игровой мир помещён в отдельный вьюпорт, в котором нет HUD. Таким образом можно использовать текстуру этого вьюпорта в других шейдерах без оглядки на этот самый HUD.

## Открытие меню

Открытие меню паузы сопровождается анимацией из 10 фреймов, каждый из которых длится 3/60 секунды. Каждый фрейм это квадратная SVG-картинка, отмасштабированная под размер вьпорта. Такой выбор был сделан из-за дальнейшего адаптирования интерфейса под разные разрешения и соотношения сторон. 

Некоторые фреймы дополнительно соправаждаются масками для того чтобы интерфейс полностью не перекрывал геймплейную сцену.

Фреймы можно было показывать с помощью `AnimationPlayer`, но вариант с твинами мне нравится больше. Поэтому вся анимация это последовательные колбеки с задержкой.

Помимо этого выполняются анимации для курсора, опций и 3d модели. Тоже с помощью твинов.

А ещё в этот момент нужно останавливать рендер игровой сцены, потому что в ней всё равно ничего происходить не должно. Это позволяет улучшить производительность.

## Бэкграунд

Под бэкгранудом я имею в виду размытую текстуру на заднем плане, похожую на воду.

Во-первых задник комплексный и состоит из нескольких нодов:

1. Текстура с геймплейного вьюпорта с мапингом цвета.
2. Колебания по синусу, имитирующие потоки воды.
3. Затенение синего цвета.
4. Пузырьки и рябь раз.
5. Рябь два.
6. Гаусовый блюр.
7. Градиент раз.
8. Градиент два.

 Мапинг цвета мапит цвет по яркости к константному градиенту на 5 цветов.

> Яркость считается по формуле `L = 0.299 * RED + 0.587 * GREEN + 0.114 * BLUE`. Эту формулу придумали умные люди и описали её в [ITU-R BT.601](https://www.itu.int/rec/R-REC-BT.601-7-201103-I).

Судя по всему, в Persona 3 Reload для пузырьков и ряби используются заранее заготовленные текстуры на подобие тех, что я рисовал для открытия меню. Но я решил написать шейдер, который использует маску, шум и "булевые" операции. Получилось неплохо, тем более что потом я всё блюрю.

А вот теперь интересное. Так как бэкграунд используется в других шейдерах, то он очень сильно влияет на производительность. Чтобы влияение было минимальным, я даунскейлю его в три раза. Чтобы эффект не был заметен, я использую размытие по Гауссу. Таким образом у меня получилось уменьшить фреймтайм на 40%, оставив картинку красивой.

## Переходы между меню

Сцены, между которыми осуществляются переходы, находятся в `SubViewportContainer`ах. Анимация выхода из меню (два круга) просто твинит `progress` у соответствующего шейдера. Вход же в подменю происходит с одним дополнительным слоем, в которой шейдер дополнительно скейлит текстуру вьюпорта. За исключением этого, всё что делает шейдер это прячет текстуру (выступает в роли маски).

Когда я открываю главное меню из подменю, я меню `progress` этого меню на `0` и изменяю `z-index` на побольше, пока проигрывается анимация перехода. Затем я прячу подменю и возращаю `z-index` назад. В качестве альтернативы можно было бы сделать несколько ресурсов с материалами-масками и навешивать их на `SubViewortContainer`ы по необходимости.

Когда меню мне не нужно, я прячу соответствующий `SubViewortContainer`. Так как вьюпорты рендерят изображения только когда они видны, это позволяет улучшить производительность.

## Плавающий челик

3d модель с анимациями падения и качания. Падение проигрывается при открытии меню паузы, а качание во всех остальных случаях. Меш, скелет, анимации и камера настраивались в Blender.

Шейдер устроен дволльно просто. Если текстура прозрачная, то вместо рисуем во фрагменте бэкграунд по `SCREEN_UV`. Дополнительно для контраста используется [френель](https://godotshaders.com/snippet/fresnel/), который по краям модельки относительно камеры тоже рисует бэкграунд (нос, щёки, воротник).

## Опции меню

Текст нахдоится в отдельном вьюпорте для того чтобы ему можно было навесить красивую рябь и переливания. Рябь это искажение текстуры вьюпорта по синусу, а переливание это смещение текстуры шума.

Когда опция выбирается, она скейлится по твину и меняет свой цвет на чёрный. Также с него убирается материал с шейдером, описанным выше. Для того чтобы текст скейлился относительно центра, его `pivot_size` должен быть `size * 0.5`. Чтобы не забывать изменять `pivot_size` во время вёрстки, я начал изменять его в `_ready()`, а сам скрипт [пометил как `@tool`](https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html). Не самое изящное решение, зато быстрое и рабочее.

Когда опция анвыбирается, она скейлится назад  меняет свой цвет с помощью твинов.

## Иерархия меню

Я просто блокирую `_input(...)` и `_process(...)` для тех меню, в которых я не нахожусь. В остальном же я старался уменьшить количество вьпортов как мог и сделать структуру нодов логичной. Не то чтобы у меня получилось сделать это аккуратно, но что есть то есть. Как минимум исправить это не сложно, жаль что мне лень ;)

## Курсор

Курсор это сцена с двумя `Polygon2D` красного и белого цвета и со специальными шейдерами-масками.

Курсор перемещается к Control и адаптируется под его размер с помощью твина. При перемещении или по таймеру курсор пульсирует, используя твин для скейла.

У курсора есть необычная `blend_add` маска (шейдер), цвет которой зависит от вьюпорта с текстом под полигоном и цвета полигона. Если текст под полигоном не синий (blue < 0.3), то маска становится красной, а иначе белой. Т.е. выбранная опция (чёрный текст) становится красной, а другие опции, которые задеваются курсором, меняют свой цвет с оттенков голубого на белый. Если под полигоном текста нет, то полигон сохраняет свой цвет. Проще посмотреть на код шейдера:

```glsl
shader_type canvas_item;
render_mode blend_add;

uniform sampler2D text_viewport_texture: filter_nearest;

void fragment() {
	vec4 viewport = texture(text_viewport_texture, SCREEN_UV);
	COLOR.rgb = mix(COLOR.rgb, viewport.b < 0.3 ? vec3(1, 0, 0) : vec3(1, 1, 1), viewport.a);
}
```

## Адаптивный интерфейс

Адаптивный интерфейс это то, чем я не занимался. Только воспользовался [официальными рекомендациями](https://docs.godotengine.org/en/stable/tutorials/rendering/multiple_resolutions.html).

Таргетное разрешение я выбрал 1080p, поэтому на 1440p и 4k изображение будет мыльным.

С соотношением сторон близкими к 16:9 дела обстоят хорошо, но c условным 32:9 интерфейс становится слишком кривым. В моём случае недостаточно просто использовать якоря, нужно адаптировать текстуры и перенастраивать интерфейс. Например, придётся пересчитывать позицию и размер вьюпорта с 3d задником и передавать в spatial шейдер данные размера окна для правильного отображения текстуры и т.д.

## Тултип

Тултип в правом нижнем углу получился довольно странным. Размер и позиция тултипа считаются в скрипте в зависимости от размера строки. Т.е. текст смещается влево, но при этом справа остаётся на том же метсе.

Там же есть динамическая белая линия с информацией о меню. Они тоже считаются динмаически в зависимости от текста выше. Стоит только отметить, что линия это последовательность `─`, заканчивающаяся там где заканчивается вьюпорт. Решение изящное, но глупое и некрасивое. Можете глянуть посмеяться. 

## Твины

[`Tween`ы](https://docs.godotengine.org/en/stable/classes/class_tween.html) это удобно и красиво. Если вам понадобится проиграть новую анимацию, не забудьте остановить твин. Не используйте разные твины анимации одинаковых или зависимых свойств одновременно, потому что они будут делать это одновременно и не понятно, что в итоге получится.

## UISFX

Для проигрыша звуков я сделал отдельный autoload сцену `UISFX`, в которой лежат `AudioStreamPlayer`ы. Чтобы проиграть определённый звук, нужно обратиться к `UISFX` с указанием этого звука. У меня это выглядит как `UISFX.play_select()`, но для более обобщённой реализации можно передавать строку: `UISFX.play(&"sound_name")`.

> `&"string_name"` это [`StringName`](https://docs.godotengine.org/en/stable/classes/class_stringname.html). `StringName` же в свою очередь это хэшированная строка, т.е. единственное её достоинтсво перед `String` заключается в гораздо более дешёвой проверки на равенство. Если у вас в `UISFX.play(...)` будет огромный `match`, то в этом лучше использовать `StringName` вместо `String`.
